{"version":3,"file":"static/js/main.1aec40c6.js","mappings":"YA2XA,IAXwBA,EAAOC,EAgBzBC,EALcC,QAAQC,IAAI,EAXRJ,EAYP,CAAC,WAAY,YAZCC,EAYY,IAXlC,IAAIE,SACT,SAAAE,GAAO,OAAIC,YAAW,kBAAMD,EAAQL,EAAM,GAAEC,EAAM,KAGtD,SAAuBM,EAAQN,GAC7B,OAAO,IAAIE,SACT,SAACK,EAAGC,GAAM,OAAKH,YAAW,kBAAMG,EAAOF,EAAO,GAAEN,EAAM,GAE1D,CAIES,CAAc,CAAC,UAAW,UAAW,OAIvCC,QAAQC,IAAIV,E","sources":["index.js"],"sourcesContent":["//------------------VAR keyword\n// function sayHello(){\n//   for ( var i =0; i<5; i++){\n//     console.log(i);\n//   }\n//   console.log(i);\n// }\n// sayHello();\n// //O/p - 0,1,2,3,4,5\n\n//------------------LET KEYWORD\n// function sayHello1(){\n//   for ( let i =0; i<5; i++){\n//     console.log(i);\n//   }\n//  //console.log(i);  //error - i not defined\n// }\n// sayHello1();\n\n//--------------CONST KEYWORD\n//const x=5;\n//x=2;   //error - x is a constant\n\n// const place=\"mumbai\";\n// if(1){\n//   const place=\"mysore\";\n//   console.log(place);\n// }\n\n// console.log(place);\n\n//o/p - mysore\n//      mumbai\n\n//--------------------OBJECTS\n// const person ={\n// name: 'Savi',\n// walk(){},\n// talk(){return 'savi can talk'}\n// };\n// const name1=person.name;\n// console.log(name1);\n// console.log(person.talk());\n\n// //o/p - Savi\n// //      savi can talk\n\n//--------------object destructuring \n// const address ={\n// \tStreet: 'a',\n// \tCity: 'b',\n// \tCountry: 'c'\n\n// };\n\n// const street = address.Street;\n// const city = address.City;\n// const country = address.Country;\n\n// console.log(street);\n// console.log(address.Street);\n// console.log(city);\n// console.log(country);\n\n// console.log(address);\n\n//-------------------this keyword\n// const person1 ={\n//   name:\"Savi\",\n//   walk(){\n//     console.log(this);\n//   },\n//   };\n// person1.walk();  \n//o/p- {\"name\": \"Savi\", walk: f}\n\n//-----BUt this keyword behaves different if called it as a reference to an object\n// const person2 ={\n//   name:\"Savi\",\n//   walk(){\n//     console.log(this);\n//   },\n//   };\n// const act=person2.walk();\n// console.log(act);\n\n//Output -      {\"name\": \"Savi\", walk: f}\n//             undefined - because there is no binding\n\n//-------------binding to THIS \n\n// const person3 ={\n//   name:\"Savi\",\n//   walk(){\n//     console.log(this);\n//   },\n//   };\n\n// person3.walk();     // function in js are objects\n// const walk= person3.walk.bind(person3);\n// walk();  //call above const walk\n\n//o/p-   {\"name\": \"Savi\", walk: f}\n//       {\"name\": \"Savi\", walk: f}\n\n\n//-------------------------ARROW FUNCTIONS \n\n//----------------------- function in js are objects\n\n//js format\n// const square = function(number){\n// return number*number\n// }\n// console.log(square(7));\n\n//es 6 format for single param function - remove function kyword, remove(), add=>, remove {}, remove return\n// const square1 = number=>\n// number*number\n// console.log(square1(5));\n\n  //---------------------FUNCTIONS for array of objects\n\n    // const jobs=[\n    // { id:1, isActive: true },\n    // { id:2, isActive: true },\n    // { id:3, isActive: false },\n    // ];\n    \n    // //const activejobs=jobs.filter(function(jobs) {return jobs.isActive;}) //js format\n    // const activejobs1=jobs.filter(jobs=> jobs.isActive);\n    // console.log(activejobs1);\n\n    ///-----------Array map  - used for rendering/traversal lists of array \n\n    // const colors= ['red','green','blue'];\n    \n    // //const items= colors.map(color=> '<li>'  + color + '</li>'); //js format\n    \n    // colors.map(color=> `<li>${color}</li>`);\n    // console.log(colors);   // ${color} - called template literal\n    \n\n    //-----------Spreading / concatenate 2 arrays / .. . operator\n\n// const first = [1,2,3];\n// const second = [4,5,6];\n\n// //const combined = first.concat(second); //js\n// const combined1 = [...first, ...second];\n// console.log(combined1);\n\n// //---------------Also helps in cloning a array:\n\n// const array1=[1,2,3];\n// const clone= [...array1 ];\n// console.log(array1);\n// console.log(clone);\n\n//-----------------------REST operator\n\n// const sum=(a,b)=>{\n// console.log(a+b);\n// }\n// sum(3,3);\n// //o/p- 6\n\n// //but if more than 2 params- still op is 6 because \n// sum(3,3,7,5,6,2,66);\n// //o/p - 6\n\n// //to show  all numbers- we use ...\n// const sum1=(...a)=>{\n//   console.log(...a);\n// }\n// sum1(1,2,3,33,555);\n// //o/p- array of numbers -1 2 3 33 555 \n\n// //to add all numbers\n// const sumAll=(...a)=>{\n// //console.log(...a);\n// let total=0;\n// for ( let i of a){\n//   total+=i;\n//   //console.log(total);\n// }\n// console.log(total);\n// }\n// sumAll(1,2,3,4,5);\n\n\n//---------------------------rest\n\n// const sum=(a,b,c,...d)=>{\n//   console.log(a);\n//   console.log(b);\n//   console.log(c);\n//   console.log(d);\n//   console.log(d.length);\n//   console.log(...d);\n// };\n// sum(2,4,6,1,\"eeee\",5,5,\"c\");\n\n\n//------------------------------DEFAULT PARAMETER \n\n// const multiply=(a,b)=>{\n//   return a*b;\n// }\n// console.log(multiply(3,3));\n// //o/p=9\n// //but if we forget 1 param and alllocate a default value of param \n// //to be used in method\n\n// const multiply1=(a,b=2)=>{\n//   return a*b;\n// }\n// console.log(multiply1(3));\n// //o/p=6\n\n    //---------------------CLASSES\n\n    //Suppose we have 2 objects: utilizing same data & method: - need redeclaration & correction at multiple places - so we will make \n    //classes out of common data & methods\n\n    // const person1 ={\n    // Name: \"Mosh\",\n    // walk(){\n    // console.log(\"walk\");\n    \n    // }\n    // };\n    \n    // const person2= {\n    //   Name: \"Mosh\",\n    //   walk(){\n    //   console.log(\"walk\");\n    //   }\n    // };\n\n    // class Person3{\n    //   constructor(name){\n    //   this.name= name;\n    //   }\n    //   walk(){\n    //   console.log(\"walk\");\n      \n    //   }\n      \n    //   }\n      \n    //   const person= new Person3('Savi');           //calling constructor above\n    //   person.walk();\n      \n\n//------------------------------INHERITENCE & SUPER constructor ( child class always calls super const of parent class)\n\n// class Person{\n//   constructor(name){\n//   this.name= name;\n//   }\n//   walk(){\n//   console.log(\"walk\");\n  \n//   }\n  \n//   }\n  \n// class Teacher extends Person {\n//     constructor(name,degree){\n//       super(name);  //will grab value of name from parent class\n//       this.degree= degree;\n//     }\n//     teach(){\n//     console.log('teach');\n//     }\n    \n//     }\n    \n//     const teacher=new Teacher('Laila', 'Msc');\n//     console.log(teacher.name);\n//   teacher.walk(); \n\n//   //o/p- Laila, walk\n\n///--------------------------MODULES- SEGREGATION OF PARENT _CHILD CLASSES IS CALLED MODULERIZATION\n\n// import Teacher from \"./teacher\"\n//   const teacher=new Teacher('Laila', 'Msc');\n// teacher.walk();\n\n///----------------------------------promises\n\n\n// let p = new Promise((resolve,reject)=>{\n// let a = 1+1\n// if (a ===2){\n//   resolve('success')\n  \n// }\n// else{\n//   reject('failed')\n \n// }\n\n// })\n\n// p.then((message)=>{\n// console.log('This is in then   '  +message)\n// }).catch((message)=>{\n \n//   console.log('This is in Catch  '  +message)\n// })\n\n    \n// //o/p- This is in then   success\n\n//---------------------------- Promise example--with finally------------------------\n// function handleJimWork() {\n//   return new Promise((resolve, reject) => {\n//     // Slow method that runs in the background\n//     //assume doJimWork() is false;\n//     const doJimWork=true;             //also test keeping it false\n//     if (doJimWork===true) {\n//       resolve(100)\n//     } else {\n//       reject(\"Jim broke his leg\")\n//     }\n//   })\n// }\n\n// handleJimWork().then(amount => {\n//   console.log(`Jim paid you ${amount} dollars`)         //amount- is caught be param filled in resolve() funtion call\n// }).catch(reason => {\n//   console.error(`Error: ${reason}`)                     //reason- is caught be param filled in rejectS() funtion call\n// }).finally(() => {\n//   console.log(\"This always runs\")                          //.finally() always runs \n// })\n\n// //----------------------------promise.all()\n// function one() {\n//   return new Promise(resolve => {\n//     //doSomething()\n//     resolve(\"From One\")\n//     console.log(\"inside function one \");\n//   })\n// }\n\n// function two() {\n//   return new Promise(reject => {\n//     //doSomethingElse()\n//     reject(\"From Two\")\n//     console.log(\"inside function two \");\n//   })\n// }\n\n// const allPromise = Promise.all([one(),two()]);\n\n// allPromise.then(values => {\n//   console.log(\"inside all promises then\"); // [valueOfPromise1, valueOfPromise2, ...]\n// }).catch(error => {\n//   console.log(\"inside all promises catch\")  // rejectReason of any first rejected promise\n// }\n\n// );\n\n///------------another example- promise.all - fail-fast \n\nfunction resolveTimeout(value, delay) {\n  return new Promise(\n    resolve => setTimeout(() => resolve(value), delay)\n  );\n}\nfunction rejectTimeout(reason, delay) {\n  return new Promise(\n    (r, reject) => setTimeout(() => reject(reason), delay)\n  );\n}\n\nconst allPromise1 = Promise.all([\n  resolveTimeout(['potatoes', 'tomatoes'], 1000),\n  rejectTimeout(['oranges', 'apples'], 1000)  \n]);\n// wait...\nconst lists = allPromise1;\nconsole.log(lists);\n\n// after 1 second\n//console.log(lists); \n// [['potatoes', 'tomatoes'], ['oranges', 'apples']]\n\n//  If at least one promise in the promises array rejects, \n//then the promise returned by allPromise = Promise.all([...]) rejects too â€” with the same reason.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"names":["value","delay","lists","Promise","all","resolve","setTimeout","reason","r","reject","rejectTimeout","console","log"],"sourceRoot":""}